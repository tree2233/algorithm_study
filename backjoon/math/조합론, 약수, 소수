1. 이항계수 구하기
nCr을 구한다고 칠 때(n -> n-r+1까지 곱하면서 1 -> n까지 나눌 때)
n에서 내림순, 1에서 올림순의 순서대로 곱하고 나누면 나눗셈으로 인한 소숫점 버림으로 발생하는 오차가 생기지 않는다.
잘 생각해보자 2를 나누는 차례에선 이미 n과 n-1이 곱해진 상태이다. 
즉 나열된 숫자 2개가 곱해졌기 때문에 둘 중 하나는 무조건 2의 배수가 존재한다. 
그 다음 n-2까지 곱하고 3을 나눌 차례다 총 3개의 나열된 수가 곱해졌기 때문에 3개의 숫자중 1개는 무조건 3의 배수가 된다.
이렇게 4의 배수, 5의 배수도 계속해서 1개 이상은 무조건 존재할 수밖에 없기 때문에 소숫점 버림이 발생하지 않는다.

while(i = 0; i < r; i++) {
    res *= n-i;
    res /= i+1;
}

---------------------------------------------------------------------------------------------------------------------------------------------------------

2. 0! = 1
nC0 = 1이잖아 그런데 nC0 = n!/n!(n-n)! 이거든 (n-n)! = 0! 이니 0! = 1이라 정의하는 거다.

---------------------------------------------------------------------------------------------------------------------------------------------------------

3. 유클리드 호제법
A, B가 주어졌을 때, 나누어 떨어지지 않는다면 작은 값으로 큰 값을 나눈 나머지를 R이라 한다. 
A(or B) 와 R이 나누어 떨어지는게 확인, 떨어지지 않는다면 다시 작은 조각으로 큰 조각을 나눈 나머지로 떨어질 때까지 반복한다. 
이렇게 반복하면 작은 조각이 큰 조각이 나눌 수 있을 때, 이미 이전 것들은 큰 조각으로 전부 나눌 수 있는 것들의 집합이니 작은 조각도 나머지를 전부 나눌 수 있게 된다. (GCD는 재귀함수(큰 값, 나눌 값)의 형태로 편하게 구현이 가능하다.)

while(A%B!=0) { //탈출후, B가 최대공약수
    R = A%B; //단, 처음 시작시에 A > B의 형태여야 한다.
    A = B;
    B = R;
}

---------------------------------------------------------------------------------------------------------------------------------------------------------

4. 최소공배수
A, B의 최소공배수는 A*B/최대공약수가 된다. 
최대 공약수의 인수들은 어차피 똑같이 가지고 있기 때문에 공배수가 인수들을 2배로 가지지 않으면 A, B롤 동시에 나눠지면서 최소인 배수가 된다. 
A, B가 동시에 가지고 있지 않은 것들의 곱 + 최대공약수 1번이 최소공배수다.

---------------------------------------------------------------------------------------------------------------------------------------------------------

5. 에라토스테네스의 체
2~N까지의 배수들을 채에 거르듯 곱하면서 소수인지를 판별하는 방법, 작은 숫자의 배수부터 거르기 때문에 실시간으로 숫자가 소수인지 아닌지 판별할 수 있음.

count = 2+2;
while(count <= MAX_NUM) {
    notPrime[count] = 1;
    count += 2;
}
v.emplace_back(2);

for(i = 3; i <= MAX_NUM; i+=2) {
    count = i+i;
    
    if(!notPrime[i]) { //이전에 작은 숫자들의 배수들을 이미 걸렀기 때문에 지금 참조한 숫자가 notPrime배열에 존재하지 않는다면 이 숫자는 소수이다.
        v.emplace_back(i); 
        
        while(count <= MAX_NUM) {
            notPrime[count] = 1;
            count += i;
        }
    }
}

---------------------------------------------------------------------------------------------------------------------------------------------------------

6. nlog(n) 시간 복잡도 소수 판별
그냥 반복문을 한번 돌려 소수를 판별하면 n의 시간이 걸린다. 2의 배수를 제외하면 n/2의 시간이 걸린다. 
그런데 어떤 숫자 N은 A*B의 곱으로 구성된다. 결국 2개 숫자의 곱으로 구성되는 것이다.
즉 약수들의 조합은 sqrt(N) 이전의 숫자들로 구성할 수 있다는 것이고, 소수를 찾기 위해 약수를 찾을 때, sqrt(N)이전에 나눠지는 숫자가 존재하지 않으면, 
sqrt(N)이후로도 N을 나누는 숫자가 존재하지 않는다는 것이다.
그렇기 때문에 나눌 숫자 i의 제곱이 나눌 숫자 N보다 크다면 그 숫자 i는 N의 제곱근을 넘는 다는 것이고, 약수가 존재했다면 i 이전에 나왔을 것이다.
그렇지만 나오지 않고 i까지 도달했기 때문에 약수가 존재하지 않는 소수라는 결론을 내릴 수 있는 것이다.

bool isPrime(int num) {
    int i;
    
    if(num <= 1)
        return false;
    
    if(num != 2&&num%2 == 0)
        return false;
    
    for(i = 3; i*i <= num; i+=2) {
        if(num%i == 0)
            return false;
    }
    
    return true;
}

---------------------------------------------------------------------------------------------------------------------------------------------------------

7. 
